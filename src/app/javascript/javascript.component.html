<div class="container pt-3">
  <h1 class="display-4">JavaScript <span class="text-primary titleTS" (click)="showTS()">& TypeScript</span></h1>
  <div>
    <small>Fonte: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide">Guida ufficiale MDN <i class="fas fa-external-link-alt icon-external-link"></i></a></small>
    <small class="hiddenTS">Fonte: <a href="https://www.typescriptlang.org/docs/home.html">Guida ufficiale TS <i class="fas fa-external-link-alt icon-external-link"></i></a></small>
  </div>

  <div class="mt-4">
    <p>
      JavaScript è case sensitive e utilizza i caratteri Unicode.
      Uno statement non richiede il ; se è l'unico nella riga, ma è meglio metterlo comunque.
      Una linea di commento si inserisce con <code>//</code>, mentre un blocco è racchiuso in <code>/* */</code>.
    </p>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Variabili</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>

    <p>Le variabili possono essere definite in tre modi:</p>
    <ul>
      <li><code>var</code> - variabile base</li>
      <li><code>let</code> - varibile locale, block scoped</li>
      <li><code>const</code> - costante, block scoped, deve essere inizializzata, non può avere lo stesso nome di una variabile o di una funzione; un oggetto costante può essere modificato nei suoi campi (idem per un array)</li>
    </ul>
    <p>
      Il valore di una variabile è <code>undefined</code> finché non è inizializzata.
      Si può controllare se una variabile ha un valore con <code>=== undefined</code>.
      In un contesto booleano una variabile <code>undefined</code> assume il valore <code>false</code>, in un contesto numerico assume il valore <code>NaN</code> (not a number).
      In un contesto booleano una variabile <code>null</code> assume il valore <code>false</code>, in un contesto numerico assume il valore 0.
    </p>
    <p>
      JS dà la possibilità di riferirsi ad una variabile dichiarata successivamente (solo con var), tuttavia mantiene il valore <code>undefined</code> quando viene usata prima della dichiarazione.
      Questa proprietà è detta Variable Hoisting.
    </p>
    <p>Le variabili globali sono proprietà dell'oggetto global window.</p>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Tipi (6 primitivi + object)</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
      <ul>
        <li>Boolean</li>
        <li>null</li>
        <li>undefined</li>
        <li>Number</li>
        <li>String</li>
        <li>Symbol</li>
      </ul>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Conversione Tipi</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      JS è tipato dinamicamente: non necessita che venga specificato il tipo e i tipi vengono convertiti durante l'esecuzione in base alle necessità.
      Quando una variabile ha un valore String + Number, il Number viene convertito a String. Se invece vengono usati operatori diversi dal +, la stringa viene convertita in numero.
      Un numero memorizzato come stringa è possibile convertirlo manualmente con <code>parseInt()</code> e <code>parseFloat()</code>, entrambi metodi di Number.
    </p>

    <p class="hiddenTS">
      TS invece aggiunge la possibilità di usare tipi statici tramite type annotations, rendendo più facile l'analisi statica del codice e bloccando la conversione automatica.
      Le type annotations si possono usare sulle variabili, sui parametri delle funzioni e permettono anche di definire il tipo di ritorno delle funzioni.
      Una volta usata l'annotation, il tipo dichiarato è fisso e non è possibile passare valori del tipo errato.
    </p>
    <pre class="bg-light rounded-right mx-auto  border-info hiddenTS"><code>
      var name : string;
      function greeter(person: string): string &#123;
        return "Hello, " + person;
      &#125;
    </code></pre>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Condizioni</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      Le istruzioni condizionali usano:
    </p>
    <ul>
      <li>if...else</li>
      <li>switch</li>
    </ul>
    <p>Valori che valgono come false:</p>
    <ul>
      <li>false</li>
      <li>undefined</li>
      <li>null</li>
      <li>0</li>
      <li>NaN</li>
      <li>" "</li>
    </ul>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Eccezioni</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      Similmente ad altri linguaggi, le eccezioni sono lanciate dal throw, gestite da un try...catch e può avere un finally conclusivo.
      L'errore lanciato può essere di qualsiasi tipo, ma conviene usare quelli definti da
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types">ES6 <i class="fas fa-external-link-alt icon-external-link"></i></a> o dal
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/DOMException">DOM <i class="fas fa-external-link-alt icon-external-link"></i></a>.
    </p>
    <p>
      Un modo alternativo per gestire il flusso di operazioni asincrone è l'uso delle Promises.
      Un oggetto Promise può avere 4 stati:
    </p>
    <ul>
      <li>pending - in attesa</li>
      <li>fulfilled - operazione a buon fine</li>
      <li>rejected - operazione fallita</li>
      <li>settled - fulfilled o rejected, ma non pending</li>
    </ul>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Iterazioni</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      Esistono diversi modi per iterare:
    </p>
    <ul>
      <li>for</li>
      <li>while</li>
      <li>do...while</li>
      <li>for...in su array</li>
      <li>for...of su oggetti iterabili</li>
    </ul>
    <pre class="bg-light rounded-right mx-auto  border-info"><code>
        for (variable in/of object) &#123;
          statements
        &#125;
    </code></pre>
    <p>Il flusso di un'iterazione può essere interrotto con un break o è possibile passare all'iterazione successiva con il continue.
      Esiste inoltre la funzione forEach() per eseguire una data funzione su ogni elemento di un array o un oggetto.
    </p>
    <pre class="bg-light rounded-right mx-auto  border-info"><code>
      array.forEach(function(element) &#123;
          console.log(element);
      &#125;);
    </code></pre>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Funzioni</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      Una funzione è definita con la keyword <code>function</code>. I parametri di tipo primitivo sono passati per valore e non cambiano al di fuori della funzione.
      Invece se vengono passati oggetti, la funzione può modificare le sue proprietà e le modifiche rimangono visibili anche all'esterno della funzione.
      Una funzione può accedere a tutte le variabili e funzioni definite nello scope in cui è definito.
    </p>
    <p>
      Esiste la possibilità di creare funzioni tramite espressioni.
      Queste funzioni possono essere anonime o avere un nome utililizzabile per chiamate ricorsive.
      La particolarità di questa soluzione è che permette di passare funzioni ad altre funzioni come parametro.
    </p>
    <pre class="bg-light rounded-right mx-auto  border-info"><code>
      var f;
      var a = "variabile";
      if(condizione)  f = function(a) &#123; statements_1 &#125;
      else  f = function (a) &#123; statementss_2 &#125;
      function doSomething(f, a)&#123;
        return f(a);
      &#125;
    </code></pre>
    <p>
      Una funzione può essere definita dentro un'altra funzione.
      La funzione interna è detta <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#Closures">closure <i class="fas fa-external-link-alt icon-external-link"></i></a> ed è privata rispetto la funzione esterna, mentre quella interna eredita lo scope della funzione esterna. 
    </p>
    <p>
      Gli argomenti di una funzione sono memorizzati in un oggetto-array: <code>arguments[i]</code>.
      Grazie a questo oggetto è possibile chiamare una funzione con più parametri rispetto a quelli che accetterebbe, utile se non si sa in anticipo il numero di argomenti passati.
      I parametri possono avere un valore di default assegnato nella definizione della funzione.
      Similmente ad arguments, si può raggruppare un numero indifinito di parametri in un array utilizzando i parametri rest: <code>...argomenti</code>.
    </p>
    <p>
      Le funzioni freccia (arrow function expression) sono particolari funzioni anonime, senza this, arguments, super e new che hanno una sintassi più breve.
      Il vantaggio di non avere un proprio this è di essere più chiaro in un contesto ad oggetti.
      Queste funzioni hanno i parametri di input prima della freccia e l'output/codice da eseguire dopo la freccia.
    </p>
    <pre class="bg-light rounded-right mx-auto  border-info"><code>
      f(input => output);
    </code></pre>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Espressioni e operatori</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      Ci sono operatori di diverso tipo: 
    </p>
    <ul>
      <li>Assegnazione</li>
      <ul>
        <li>Assegnazione standard ( = )</li>
        <li>Assegnazione con operazione ( +=, *=, -=, /= )</li>
      </ul>
      <li>Confronto</li>
      <ul>
        <li>Uguaglianza ( == ) - confronta i due operandi convertendoli se non sono dello stesso tipo</li>
        <li>Uguaglianza stretta ( === ) - confronta i due operandi senza conversione</li>
        <li>Disuguaglianza ( !=, !== )</li>
        <li>Maggiore e minore ( >, < )</li>
      </ul>
      <li>Aritmetici ( +, -, *, / )</li>
      <li>Su bit ( &, |, ^ )</li>
      <li>Logici ( &&, ||, ! ), valutati secondo cortocircuito, quindi:</li>
      <ul>
        <li>false && qualcosa -> false</li>
        <li>true || qualcosa -> true</li>
      </ul>
      <li>Relazionali</li>
      <ul>
        <li>in - ritorna true se una proprietà è presente nell'oggetto</li>
        <li>instanceof - ritorna true se l'oggetto è del tipo specificato</li>
      </ul>
      <li>Unari</li>
      <ul>
        <li><code>delete</code> - cancella un oggetto, un elemento di un array o la proprietà specificata di un oggetto</li>
        <li><code>typeof</code> - ritorna il tipo dell'operando come stringa</li>
        <li><code>void</code> - indica che un'espressione va valutata senza ritornare un valore</li>
      </ul>
      <li>Operatore virgola</li>
      <li>Operatore ternario condizionale ( a ? b : c )</li>
    </ul>
    <p>
      Le principali espressioni note:
    </p>
    <ul>
      <li><code>this</code> - si riferisce all'oggetto corrente e si usa con <code>this.propertyName</code> o con <code>this['propertyName']</code></li>
      <li><code>new</code> - crea un'istanza di un oggetto</li>
      <li><code>super</code> - keyword utilizzata per chiamare funzioni del genitore</li>
    </ul>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Numeri e date</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      I numeri in JS sono implementati in doppia precisione e non sono distinti tra integer e float. Ci sono tre valori simbolici: 
    </p>
    <ul>
      <li><code>+Infinity</code></li>
      <li><code>-Infinity</code></li>
      <li><code>NaN</code></li>
    </ul>
    <p>
      L'oggetto Number ha come proprietà costanti numeriche e alcuni metodi d'utilità.
      L'oggetto Math invece mette a disposizione costanti e funzioni matematiche.
      Alcuni metodi utili: <code>round</code> (arrotonda), <code>fix(n)</code> (tronca a n cifre decimali).
    </p>
    <p>
      Le date in JS vengono gestite tramite l'oggetto Date che mette a disposizione diversi metodi.
    </p>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Espressioni regolari</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>
    <p>
      JS mette a disposizione le espressioni regolari, che si possono creare come oggetti o come litterali.
      In particolare, se l'espressione è nota e costante, conviene usare la forma litterale, mentre se può cambiare o arriva dall'esterno, conviene creare l'oggetto con il costruttore.
    </p>
    <pre class="bg-light rounded-right mx-auto  border-info"><code>
      var RE = /ab+c/;

      var re = new RegExp('ab+c');
    </code></pre>
    <p>
      L'elenco completo di caratteri speciali usati nelle espressioni regolari si trovano nella <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">guida <i class="fas fa-external-link-alt icon-external-link"></i></a>.
    </p>
    <p>
      Le espressioni regolari sono di solito utilizzate nei metodi test e exec di RegExp e nei metodi match, replace, search, e split di String.
      Un uso tipico delle espressioni regolari è nel controllo degli input testuali.
    </p>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Array</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>

    <p>
      Un array contiene valori riferibili con un indice. Un array può venire creato in diversi modi:
    </p>
    <pre class="bg-light rounded-right mx-auto  border-info"><code>
      var arr = new Array(element0, element1, ..., elementN);
      var arr = Array(element0, element1, ..., elementN);
      var arr = [element0, element1, ..., elementN];
    </code></pre>

    <p>
      Array ha la proprietà length che indica la sua lunghezza. Se viene assegnato un nuovo valore a length, l'array viene troncato di conseguenza.
      Sono disponibili diversi metodi come: 
    </p>
    <ul>
      <li><code>concat</code> unisce due array</li>
      <li><code>join(" , ")</code> ritorna una stringa con gli elementi concatenati con il carattere usato come delimiter</li>
      <li><code>push</code> aggiunge un elemento in coda e ritorna la length/li>
      <li><code>pop</code> rimuove e ritorna l'ultimo elemento</li>
      <li><code>shift</code> rimuove e ritorna il primo elemento</li>
      <li><code>unshift</code> aggiunge un elemento all'inizio e ritorna la length</li>
      <li><code>slice(start_index, end_index)</code> estrae una sezione di array</li>
      <li><code>splice(index, n, element1, element2, ...)</code> rimuove n elementi a partire dall'indice e aggiunge nuovi elementi (opzionale)</li>
      <li><code>reverse</code> rovescia l'array</li>
      <li><code>sort</code> ordina gli elementi</li>
      <li><code>indexOf(searchElement)</code> trova l'indice di searchElement</li>
      <li><code>lastIndexOf(searchElement)</code> cerca l'indice di searchElement, ma partendo dalla fine</li>
    </ul>
    <p>
      I successivi metodi sono detti iterativi perchè agiscono su tutto l'array e usano le funzioni callback:
    </p>
    <ul>
      <li><code>forEach</code> esegue la callback per ogni elemento e ritorna undefined</li>
      <li><code>map</code> ritorna un array con valori derivati dall'esecuzione della callback su ogni elemento</li>
      <li><code>filter</code> ritorna un array con gli elementi per cui la callback ha ritornato true</li>
      <li><code>every</code> ritorna true se la callback ritorna true per tutti gli elementi</li>
      <li><code>some</code> ritorna true se la callback ritorna true per almeno un elemento</li>
      <li><code>reduce</code></li>
      <li><code>reduceRight</code></li>
    </ul>

    <p>
      Esistono inoltre gli <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">array tipizzati <i class="fas fa-external-link-alt icon-external-link"></i></a> che permettono di manipolare dati binari.
    </p>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Map e Set</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>

    <p>
      <code>Map</code> è un contenitore di elementi associati con una chiave univoca, iterabile secondo l'ordine di inserimento. I principali metodi sono:
    </p>
    <ul>
      <li><code>set</code></li>
      <li><code>get</code></li>
      <li><code>has</code></li>
      <li><code>delete</code></li>
      <li><code>clear</code></li>
      <li><code>size</code> (è una proprietà)</li>
    </ul>
    <p>
      Rispetto agli oggetti ha alcuni vantaggi:
    </p>
    <ul>
      <li>la chiave può essere qualsiasi valore nella mappa, mentre negli oggetti sono sempre stringhe</li>
      <li>si può ottenere facilemente la grandezza della mappa</li>
      <li>è iterabile secondo l'ordine d'inserimento</li>
    </ul>
    <p>
      In sinstesi, conviene usare la <code>Map</code> quando il tipo delle chiavi è sconosciuto fino a runtime, e quando le chiavi sono dello stesso tipo e i valori sono dello stesso tipo.
    </p>
    <p>
      <code>Set</code> è un contenitore di valori univoci iterabili secondo l'ordine di inserimento. I principali metodi sono:
    </p>
    <ul>
      <li><code>add</code></li>
      <li><code>has</code></li>
      <li><code>delete</code></li>  
      <li><code>size</code> (è una proprietà)</li>
    </ul>
    <p>
      Rispetto agli array ha alcuni vantaggi:
    </p>
    <ul>
      <li><code>indexOf</code> degli array è più lento del <code>has</code></li>
      <li>è più facile cancellare un elemento dato il valore</li>
      <li>facilita la gestione dei duplicati</li>
      <li><code>NaN</code> non è possibile trovarlo con <code>indexOf</code></li>
    </ul>

    <p>
      Esistono anche le alternative <code>WeakMap</code> e <code>WeakSet</code>, che accettano solo oggetti e non valori generici. 
    </p>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Oggetti e il modello ad oggetti</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>

    <p>
      Un oggetto JavaScript ha proprietà associate accessibili con l'operatore <code>.</code> o  con <code>['nome_proprietà']</code>, e a differenza di altri linguaggi di programmazione è possibile aggiungere proprietà in qualsiasi momento.
      La notazione con le quadre è molto utile quando si sa il nome della proprietà solo a runtime. Un oggetto può essere creato tramite inizializzazione o tramite il costruttore.
      Ci sono tre modi (introdotti da ES5) per enumerare le proprietà di un oggetto:
    </p>
    <ul>
      <li><code>for...in</code></li>
      <li><code>Object.keys(obj)</code></li>
      <li><code>Object.getOwnPropertyNames(obj)</code></li>
    </ul>

    <p>
      Tutti gli oggetti ereditano almeno da un oggetto, detto <code>prototype</code>. Si può aggiungere una proprietà a tutti gli oggetti di un tipo già definito tramite <code>obj.prototype.new_property</code>.
      Un oggetto può avere un metodo, ovvero una funzione assegnata ad una proprietà dell'oggetto. Una proprietà può essere rimossa con il <code>delete</code>.
    </p>

    <p>
      Gli oggetti sono di tipo riferimento, quindi due oggetti distinti non saranno mai uguali anche se hanno le stesse proprietà. Il confronto tra oggetti risulta vero solo se confrontato con sè stesso.
    </p>

    <p>
      JavaScript è un linguaggio orientato ai prototipi più che alle classi. La differenza sta nella distinzione tra classi ed istanze.
      I linguaggi orientati alle classi, come C++ e Java, hanno questa distinzione, mentre JS usa semplicemente gli oggetti.
      Un oggetto può essere usato come prototipo per la creazione di un altro oggetto che eredita in questo modo le stesse proprietà.      
      Non esiste l'ereditarietà multipla.
    </p>

    <p>
      JS controlla la presenza di una proprietà in 4 passaggi:
    </p>
    <ol>
      <li>Controlla se la proprietà esiste localmente nell'oggetto e se presente ritorna quel valore</li>
      <li>Se non c'è, controlla nella prototype chain</li>
      <li>Se un oggetto della prototype chain ha la proprietà, ritorna quel valore</li>
      <li>Se non viene trovata, l'oggetto non ha la proprietà</li>
    </ol>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Promise</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>

    <p>
      Una <code>Promise</code> è un oggetto che rappresenta il completamento o meno di un'operazione asincrona. Di solito è un oggetto ritornato a cui si collega una callback. Esempio:
    </p>
    
    <pre class="bg-light rounded-right mx-auto border-info"><code>
      functionAsync().then(successCallback, failureCallback);
    </code></pre>

    <p>
      Il vantaggio delle callback passate con il then() è che vengono sempre eseguite, indipendentemente dal successo o l'insuccesso dell'operazione asincrona, dopo il corrente ciclo di eventi JS. 
      Un altro vantaggio è la concatenazione (chaining) di più promise, utile quando vanno eseguite più operazioni asincrone che agiscono sul risultato della precedente. Un esempio di concatenazione con le funzioni freccia (arrow function)
      e la catch finale è il seguente:
    </p>

    <pre class="bg-light rounded-right mx-auto border-info"><code>
      doSomething()
      .then(result => doSomethingElse(result))
      .then(newResult => doSomethingOptional()
        .then(optionalResult => doSomethingExtraNice(optionalResult))
        .catch(e => &#123; console.log('Catch solo per doSomethingOptional e doSomethingExtraNice') &#125;))
      .then(finalResult => &#123;
        console.log(`Got the final result: $&#123;finalResult&#125;`);
        &#125;)
      .catch(failureCallback)
      .then(() => &#123;
        console.log('Do this, no matter what happened before');
        &#125;);     
    </code></pre>

    <p>
      con <code>catch(failureCallback)</code> che è la forma contratta per <code>then(null, failureCallback)</code>. La catch viene raggiunta in caso di eccezione in uno dei passi precedenti della catena.
      Tuttavia il catch ha effetto solo nel suo scope e se viene innestato ignora i fallimenti esterni; può essere utile per un controllo più fine degli errori.
      Anche dopo il catch è possibile concatenare. In una concatenazione deve sempre esserci il ritorno per le callback successive.
    </p>
    
    <p>
      Esiste un problema con le vecchie API che si aspettano ancora le callback di successo e fallimento passate nel vecchio stile. La soluzione è creare una promise attorno alla funzione problematica.
    </p>

    <p>
      Sono disponibili alcuni metodi utili nella composizione di Promise.
      <code>Promise.resolve()</code> e <code>Promise.reject()</code> creano promise già risolte o rifiutate, <code>Promise.all()</code> e <code>Promise.race()</code> permettono di eseguire operazioni asincrone in parallelo.
      ES8 introduce async e await che semplifica la composizione sequenziale.
    </p>

    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Iteratori e generatori</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>   

    <p>
      Un iteratore è un oggetto che definisce una sequenza e ha un possibile valore di ritorno.
      In particolare, è un oggetto che ha un metodo <code>next()</code> che ritorna un oggetto con un due proprietà:
      <code>value</code>, che indica il valore successivo della sequenza, e <code>done</code> che indica con un booleano se l'ultimo valore della sequenza è stato consumato.
      L'oggetto <code>Iterator</code> è quindi iterabile con il metodo <code>next</code> e viene consumato una volta giunto all'ultimo elemento.
    </p>

    <p>
      Per quanto utili, non sono facili da creare gli iteratori custom. Una valida alternativa sono le generator function.
      Con la sintassi <code>function*</code> si definisce una funzione con comportamento iterativo. [...]
    </p>

    <p>
      Un oggetto è iterabile se definisce il suo comportamento iterativo. Per fare ciò deve implementare il metodo <code>@@iterator</code>.
    </p>
    
    <hr>
    <div class="row">
      <div class="col-auto mr-auto">
        <h2 class="lead">Meta programmazione</h2>
      </div>
      <div class="col-auto">
        <i class="fas fa-angle-double-up icon-go-top text-primary" (click)="goTop()"></i>
      </div>
    </div>

    <p>
      ES6 introduce i <code>Proxy</code> per intercettare certe operazioni che accedono a attributi o metodi di oggetti e darne un'implementazione custom. 
      L'oggetto definisce un target e un handler contenente una "trappola".
      La guida elenca le <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming#Handlers_and_traps">trappole <i class="fas fa-external-link-alt icon-external-link"></i></a> disponibili.
    </p>

    <p>
      <a href="https://medium.com/dailyjs/how-to-use-javascript-proxies-for-fun-and-profit-365579d4a9f8">Articolo <i class="fas fa-external-link-alt icon-external-link"></i></a> interessante sull'uso di Proxy.
    </p>

  </div>
</div>